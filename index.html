<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <title>Планування занять (група "Казка")</title>
    <style>
        /* Базові стилі таблиць */
        table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 40px;
        }
        th, td {
            border: 1px solid #444;
            padding: 8px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f2f2f2;
        }

        /* Кожна таблиця (і заголовок) обгорнуті в .page, щоб контролювати розриви */
        .page {
            page-break-after: always;
            break-inside: avoid;
        }

        /* Кнопки та їх стилі */
        .no-print {
            margin: 10px 0;
        }
        button {
            padding: 8px 16px;
            margin-right: 10px;
            font-size: 14px;
            cursor: pointer;
        }
        select {
            padding: 5px;
            font-size: 14px;
            margin-right: 10px;
        }
        input {
            padding: 5px;
            font-size: 14px;
        }

        /* При друку приховуємо панелі керування (клас .no-print) */
        @media print {
            .no-print {
                display: none !important;
            }
        }

        /*
           Примусово робимо сторінку A4 альбомною при друку.
           Зменшуємо масштаб (transform: scale(0.85)) щоб таблиця краще вміщувалась.
        */
        @page {
            size: A4 landscape;
            margin: 0mm;
        }
        @media print {
            body {
                transform: scale(0.85);
                transform-origin: top left;
            }
            table, th, td {
                font-size: 12px; /* За потреби змінюйте */
            }
            .page {
                page-break-inside: avoid !important;
            }
        }

        /* NEW: Styles for the spinner overlay */
        #spinnerOverlay {
            display: none; /* Hidden by default */
            position: fixed;
            z-index: 9999;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            text-align: center;
            padding-top: 20%;
            font-size: 24px;
        }
        /* Just a simple rotating animation (optional) */
        .spinnerIcon {
            border: 6px solid #f3f3f3;
            border-radius: 50%;
            border-top: 6px solid #3498db;
            width: 40px;
            height: 40px;
            margin: 0 auto 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<!-- Блок налаштувань: вибір місяця, року, API ключа та автозаповнення -->
<div class="no-print">
    <h3>Налаштування місяця, року, API-ключа та автозаповнення</h3>

    <!-- Вибір року -->
    <label for="yearSelect">Оберіть рік:</label>
    <select id="yearSelect">
        <!-- Додайте необхідні роки -->
        <option value="2023">2023</option>
        <option value="2024">2024</option>
        <option value="2025">2025</option>
        <option value="2026">2026</option>
        <option value="2027">2027</option>
        <option value="2028">2028</option>
    </select>

    <!-- Вибір місяця українською -->
    <label for="monthSelect">Оберіть місяць:</label>
    <select id="monthSelect">
        <option value="1">Січень</option>
        <option value="2">Лютий</option>
        <option value="3">Березень</option>
        <option value="4">Квітень</option>
        <option value="5">Травень</option>
        <option value="6">Червень</option>
        <option value="7">Липень</option>
        <option value="8">Серпень</option>
        <option value="9">Вересень</option>
        <option value="10">Жовтень</option>
        <option value="11">Листопад</option>
        <option value="12">Грудень</option>
    </select>

    <button id="generateWeeksBtn">Згенерувати таблиці</button>
    <br><br>

    <!-- Поле для введення API-ключа -->
    <label for="apiKeyInput">Google Gemini API Key:</label>
    <input type="text" id="apiKeyInput" placeholder="Введіть ваш ключ...">
    <button id="saveApiKeyBtn">Зберегти ключ</button>
    <br><br>

    <!-- Кнопки автозаповнення -->
    <button id="autoFillWeekThemesBtn" disabled>Автозаповнення тем тижнів</button>
    <button id="autoFillDayThemesBtn" disabled>Автозаповнення тем днів</button>
    <button id="autoFillBtn" disabled>Автозаповнення (повна таблиця)</button>
    <br><br>

    <!-- Кнопка друку -->
    <button id="btnPrint">Друк</button>
</div>

<!-- NEW: Spinner overlay -->
<div id="spinnerOverlay">
    <div class="spinnerIcon"></div>
    <div>Заповнюю, очікуйте, будь ласка!</div>
</div>

<script>
    /****************************************************
     * Змінна для назв місяців українською
     ****************************************************/
    const monthNamesUkr = [
        "Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень",
        "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"
    ];

    /****************************************************
     * ВІДНОВЛЕННЯ ДАНИХ З LOCALSTORAGE (якщо були збережені)
     ****************************************************/
    document.addEventListener('DOMContentLoaded', function() {
        // Відновлюємо збережений ключ, якщо є
        const savedApiKey = localStorage.getItem('geminiApiKey');
        if (savedApiKey) {
            document.getElementById('apiKeyInput').value = savedApiKey;
        }

        // NEW: Відновлюємо збережений рік і місяць, якщо є
        const savedSelectedYear = localStorage.getItem('selectedYear');
        const savedSelectedMonth = localStorage.getItem('selectedMonth');
        if (savedSelectedYear) {
            const yearSelect = document.getElementById('yearSelect');
            yearSelect.value = savedSelectedYear;
        }
        if (savedSelectedMonth) {
            const monthSelect = document.getElementById('monthSelect');
            monthSelect.value = savedSelectedMonth;
        }

        // Відновлюємо збережений HTML (усіх .page разом)
        const savedPages = localStorage.getItem('allGeneratedPages');
        if (savedPages) {
            // Вставимо відновлений HTML у body
            document.body.insertAdjacentHTML('beforeend', savedPages);

            // Після вставляння – знову навішаємо обробники на кнопки редагування/збереження
            reattachTableHandlers();
            reattachThemeInputHandlers();

            // NEW: Enable Edit and Save buttons if tables exist
            document.querySelectorAll('.page').forEach(page => {
                page.querySelectorAll('.editBtn, .saveBtn').forEach(btn => {
                    btn.disabled = false;
                });
            });
        }

        // Перевіряємо, чи можна активувати кнопки автозаповнення
        checkAutoFillAvailability();
    });

    /****************************************************
     * ЗБЕРІГАННЯ / ВІДНОВЛЕННЯ КОНТЕНТУ
     ****************************************************/
    function saveGeneratedPages() {
        // Iterate over all '.page' elements to set 'value' attributes
        document.querySelectorAll('.page').forEach(page => {
            page.querySelectorAll('input').forEach(input => {
                input.setAttribute('value', input.value);
            });
        });

        // Зчитуємо всі .page і зберігаємо їхній зовнішній HTML у localStorage
        const pagesHtml = Array.from(document.querySelectorAll('.page'))
            .map(page => page.outerHTML)
            .join('\n');

        localStorage.setItem('allGeneratedPages', pagesHtml);
    }

    /****************************************************
     * ФУНКЦІЯ РЕДАГУВАННЯ ТАБЛИЦЬ (вмикаємо contentEditable)
     ****************************************************/
    function editTableContent(tableId) {
        const table = document.getElementById(tableId);
        if (!table) return;
        table.querySelectorAll('td, th').forEach(cell => {
            cell.contentEditable = 'true';
        });
    }

    /****************************************************
     * ФУНКЦІЯ ЗБЕРЕЖЕННЯ ТАБЛИЦЬ (вимикаємо contentEditable)
     ****************************************************/
    function saveTableContent(tableId) {
        const table = document.getElementById(tableId);
        if (!table) return;
        table.querySelectorAll('td, th').forEach(cell => {
            cell.contentEditable = 'false';
        });

        // Після вимкнення редагування – зберігаємо все у localStorage
        saveGeneratedPages();
        alert('Дані збережено успішно!');
    }

    /****************************************************
     * ОБРОБНИКИ КНОПОК "Редагувати" / "Зберегти"
     ****************************************************/
    function reattachTableHandlers() {
        document.querySelectorAll('.editBtn').forEach(btn => {
            btn.onclick = function() {
                const tableId = this.getAttribute('data-table');
                editTableContent(tableId);
            };
        });
        document.querySelectorAll('.saveBtn').forEach(btn => {
            btn.onclick = function() {
                const tableId = this.getAttribute('data-table');
                saveTableContent(tableId);
            };
        });
    }

    /****************************************************
     * ГЕНЕРАЦІЯ "РОБОЧИХ ТИЖНІВ" МІСЯЦЯ
     ****************************************************/
    const generateWeeksBtn = document.getElementById('generateWeeksBtn');
    generateWeeksBtn.addEventListener('click', () => {
        const yearSelect = document.getElementById('yearSelect').value;
        const monthSelect = document.getElementById('monthSelect').value;

        if (!yearSelect || !monthSelect) {
            alert('Будь ласка, оберіть рік та місяць!');
            return;
        }

        // NEW: зберігаємо вибраний рік і місяць
        localStorage.setItem('selectedYear', yearSelect);
        localStorage.setItem('selectedMonth', monthSelect);

        // Видаляємо усі поточні сторінки .page
        document.querySelectorAll('.page').forEach(page => page.remove());
        // Також очистимо збережені сторінки у localStorage
        localStorage.removeItem('allGeneratedPages');

        // Парсимо обраний рік і місяць
        const year = parseInt(yearSelect, 10);
        const monthIndex = parseInt(monthSelect, 10) - 1;

        // Отримаємо "тижні" (масив масивів), де кожен тиждень складається тільки з робочих днів (пн–пт).
        const weeks = getWorkingWeeksOfMonth(year, monthIndex);
        if(weeks.length === 0) {
            alert('У цьому місяці немає робочих днів (за логікою getWorkingWeeksOfMonth).');
            return;
        }

        // Генеруємо блоки-«тижні»
        weeks.forEach((daysArray, index) => {
            const weekNumber = index + 1;

            // Перша й остання дата у тижні
            const firstDateStr = formatDateDDMM(daysArray[0]);
            const lastDateStr = formatDateDDMM(daysArray[daysArray.length - 1]);

            // Створюємо контейнер (.page)
            const pageDiv = document.createElement('div');
            pageDiv.classList.add('page');

            // Заголовок: "Тиждень X (DD.MM – DD.MM), Тема тижня: <input>"
            const h2 = document.createElement('h2');
            h2.innerHTML = `
                Тиждень ${weekNumber} (${firstDateStr} – ${lastDateStr}).
                <label> Тема тижня: <input type="text" class="week-theme-input" placeholder="Вкажіть тему тижня"> </label>
            `;
            pageDiv.appendChild(h2);

            // Кнопки редагування / збереження
            const noPrintDiv = document.createElement('div');
            noPrintDiv.classList.add('no-print');
            const editBtn = document.createElement('button');
            editBtn.textContent = 'Редагувати';
            editBtn.classList.add('editBtn');
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Зберегти';
            saveBtn.classList.add('saveBtn');

            // Встановимо унікальний ID для таблиці
            const tableId = `weekTable${weekNumber}`;
            editBtn.setAttribute('data-table', tableId);
            saveBtn.setAttribute('data-table', tableId);

            noPrintDiv.appendChild(editBtn);
            noPrintDiv.appendChild(saveBtn);
            pageDiv.appendChild(noPrintDiv);

            // Створюємо таблицю
            const table = document.createElement('table');
            table.id = tableId;
            table.classList.add('editable-table');

            // Шапка
            table.innerHTML = `
                <tr>
                    <th>Дні тижня (Тема дня)</th>
                    <th>Освітня лінія «Особистість дитини»</th>
                    <th>Освітня лінія «Дитина в соціумі»</th>
                    <th>Освітня лінія «Дитина в природному довкіллі»</th>
                    <th>Освітня лінія «Дитина у світі культури»</th>
                    <th>Освітня лінія «Мовлення дитини»</th>
                    <th>Освітня лінія «Дитина в сенсорно-математичному просторі»</th>
                    <th>Освітня лінія «Гра дитини»</th>
                </tr>
            `;

            // Додаємо рядки для кожного робочого дня тижня
            daysArray.forEach(dayDate => {
                const ddMM = formatDateDDMM(dayDate);
                const dayOfWeekName = getDayNameUkr(dayDate.getDay());

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>
                        <strong>${ddMM} (${dayOfWeekName})</strong>
                        <br>
                        Тема дня: <input type="text" class="day-theme-input" placeholder="Вкажіть тему дня">
                    </td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                `;
                table.appendChild(row);
            });

            pageDiv.appendChild(table);
            document.body.appendChild(pageDiv);
        });

        // Заново навішуємо обробники на кнопки Редагувати/Зберегти
        reattachTableHandlers();

        // Навішуємо обробники на поля вводу (щоб відстежувати, коли всі теми заповнені)
        reattachThemeInputHandlers();

        // Зберігаємо порожні згенеровані таблиці в localStorage
        saveGeneratedPages();

        // Після генерації перевіряємо кнопки автозаповнення
        checkAutoFillAvailability();
    });

    /**
     * Повертає масив «тижнів» (кожен «тиждень» – це масив робочих днів),
     * де перший тиждень починається з першого робочого дня місяця (якщо це сер/чет/пт),
     * і кожен новий понеділок створює нову таблицю.
     * Суботи і неділі пропускаються.
     */
    function getWorkingWeeksOfMonth(year, month) {
        // Спочатку зберемо всі робочі дні (пн–пт) у масив "allWorkDays".
        const allWorkDays = [];
        let d = new Date(year, month, 1);

        while (d.getMonth() === month) {
            const dayOfWeek = d.getDay(); // 0=Нд, 1=Пн, ... 6=Сб
            if (dayOfWeek !== 0 && dayOfWeek !== 6) {
                // Це робочий день (пн–пт)
                allWorkDays.push(new Date(d));
            }
            d.setDate(d.getDate() + 1);
        }

        if (allWorkDays.length === 0) return [];

        // Тепер поділимо "allWorkDays" на «тижні»:
        const weeks = [];
        let currentWeek = [];

        for (let i = 0; i < allWorkDays.length; i++) {
            const dayDate = allWorkDays[i];
            // Якщо це понеділок і "currentWeek" вже містить дні, починаємо новий тиждень
            if (dayDate.getDay() === 1 && currentWeek.length > 0) {
                weeks.push(currentWeek);
                currentWeek = [];
            }
            currentWeek.push(dayDate);
        }
        // Додаємо останній тиждень, якщо є
        if (currentWeek.length > 0) {
            weeks.push(currentWeek);
        }

        return weeks;
    }

    // Допоміжні форматери
    function formatDateDDMM(dateObj) {
        const dd = String(dateObj.getDate()).padStart(2, '0');
        const mm = String(dateObj.getMonth()+1).padStart(2, '0');
        return dd + '.' + mm;
    }
    function getDayNameUkr(dayIndex) {
        // dayIndex: 0(Нд), 1(Пн), 2(Вт), ...
        const days = [
            'Неділя',   // 0
            'Понеділок',// 1
            'Вівторок', // 2
            'Середа',   // 3
            'Четвер',   // 4
            'П’ятниця', // 5
            'Субота'    // 6
        ];
        return days[dayIndex] || '';
    }

    /****************************************************
     * ВВІД / КОНТРОЛЬ ТЕМ ТИЖНІВ ТА ДНІВ
     ****************************************************/
    function reattachThemeInputHandlers() {
        // Усі поля .week-theme-input і .day-theme-input
        const weekInputs = document.querySelectorAll('.week-theme-input');
        const dayInputs = document.querySelectorAll('.day-theme-input');

        // Слухаємо події input
        weekInputs.forEach(input => {
            input.addEventListener('input', checkAutoFillAvailability);
        });
        dayInputs.forEach(input => {
            input.addEventListener('input', checkAutoFillAvailability);
        });
    }

    // Перевірка: чи всі теми тижнів і днів заповнені
    function areAllThemesFilled() {
        const weekInputs = document.querySelectorAll('.week-theme-input');
        const dayInputs = document.querySelectorAll('.day-theme-input');
        for (let wi of weekInputs) {
            if (!wi.value.trim()) {
                return false;
            }
        }
        for (let di of dayInputs) {
            if (!di.value.trim()) {
                return false;
            }
        }
        return true;
    }

    // Перевірка для кнопок автозаповнення
    function checkAutoFillAvailability() {
        const autoFillWeekThemesBtn = document.getElementById('autoFillWeekThemesBtn');
        const autoFillDayThemesBtn = document.getElementById('autoFillDayThemesBtn');
        const autoFillBtn = document.getElementById('autoFillBtn');

        const apiKey = localStorage.getItem('geminiApiKey') || '';

        // Якщо ключа немає — кнопки вимкнені
        if (!apiKey.trim()) {
            autoFillWeekThemesBtn.disabled = true;
            autoFillDayThemesBtn.disabled = true;
            autoFillBtn.disabled = true;
            return;
        }

        // Кнопка автозаповнення тем тижнів: просто вимагає наявність ключа
        autoFillWeekThemesBtn.disabled = false;

        // Кнопка автозаповнення тем днів: вимагає, щоб всі теми тижнів були заповнені
        let allWeekThemesFilled = true;
        document.querySelectorAll('.week-theme-input').forEach(wi => {
            if (!wi.value.trim()) allWeekThemesFilled = false;
        });
        autoFillDayThemesBtn.disabled = !allWeekThemesFilled;

        // Кнопка повного автозаповнення (таблиць): вимагає, щоб усі теми тижнів і днів були заповнені
        autoFillBtn.disabled = !areAllThemesFilled();
    }

    /****************************************************
     * ЗБЕРЕЖЕННЯ API-КЛЮЧА В LOCALSTORAGE
     ****************************************************/
    const saveApiKeyBtn = document.getElementById('saveApiKeyBtn');
    saveApiKeyBtn.addEventListener('click', () => {
        const keyInput = document.getElementById('apiKeyInput').value.trim();
        if (keyInput) {
            localStorage.setItem('geminiApiKey', keyInput);
            alert('API ключ збережено успішно!');
        } else {
            alert('Введіть дійсний API ключ!');
        }
        checkAutoFillAvailability();
    });

    /****************************************************
     * NEW: Spinner / enable / disable main control buttons
     ****************************************************/
    function showSpinner() {
        document.getElementById('spinnerOverlay').style.display = 'block';
    }
    function hideSpinner() {
        document.getElementById('spinnerOverlay').style.display = 'none';
    }
    function disableAllButtons() {
        // Disable only main control buttons within .no-print
        document.querySelectorAll('.no-print button, .no-print select, .no-print input').forEach(el => {
            el.disabled = true;
        });
    }
    function enableAllButtons() {
        // Enable only main control buttons within .no-print
        document.querySelectorAll('.no-print button, .no-print select, .no-print input').forEach(el => {
            el.disabled = false;
        });
        checkAutoFillAvailability(); // re-check states
    }

    /****************************************************
     * АВТОЗАПОВНЕННЯ ТЕМ ТИЖНІВ
     ****************************************************/
    const autoFillWeekThemesBtn = document.getElementById('autoFillWeekThemesBtn');
    autoFillWeekThemesBtn.addEventListener('click', async () => {
        const apiKey = localStorage.getItem('geminiApiKey');
        if (!apiKey) {
            alert('API ключ не знайдено! Спочатку збережіть ключ.');
            return;
        }

        // Дістанемо вибраний місяць і рік
        const yearSelect = document.getElementById('yearSelect').value;
        const monthSelect = document.getElementById('monthSelect').value;
        if (!yearSelect || !monthSelect) {
            alert('Спочатку оберіть рік та місяць!');
            return;
        }

        // Disable UI and show spinner
        disableAllButtons();
        showSpinner();

        const year = parseInt(yearSelect, 10);
        const monthIndex = parseInt(monthSelect, 10) - 1;
        const monthName = monthNamesUkr[monthIndex] || "";

        try {
            // Кількість тижнів — кількість .page
            const pages = document.querySelectorAll('.page');
            const howManyWeeks = pages.length;
            if (howManyWeeks === 0) {
                alert("Немає згенерованих тижнів!");
                return;
            }

            // Створимо prompt для генерації назв/тем тижнів
            const promptText = `
Будь ласка, запропонуй ${howManyWeeks} актуальних коротких тем для тижнів у дитячому садочку в Україні 
на період: ${monthName} ${year}. 
Кожну тему подай з нового рядка. 
Теми мають бути креативними, але враховувати сезон та особливості виховання дітей дошкільного віку.
Якщо в тижні є державне свято України, будь ласка, врахуй його при формуванні теми тижня, але не зазначай факт врахування у назві. Свята повинні відповідати Григоріанському календарю.
Надай лише список тем, без нумерації, без коментарів.
            `.trim();

            const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{ text: promptText }]
                        }]
                    })
                }
            );

            if (!response.ok) {
                throw new Error(`Помилка від API: ${response.status}`);
            }
            const data = await response.json();
            let generatedText = data.candidates[0].content.parts.at(-1).text;
            
            // Розділимо результат на рядки (видаляємо можливу нумерацію)
            const lines = generatedText
                .split(/\r?\n/)
                .map(l => l.replace(/^\d+\)\s*/, '').trim())
                .filter(Boolean);

            // Заповнюємо week-theme-input
            const weekInputs = document.querySelectorAll('.week-theme-input');
            for (let i = 0; i < weekInputs.length; i++) {
                if (i < lines.length) {
                    weekInputs[i].value = lines[i];
                }
            }

            // Зберігаємо зміни
            saveGeneratedPages();
            alert("Автозаповнення тем тижнів завершено!");
        } catch (error) {
            console.error(error);
            alert("Не вдалося отримати дані від Gemini API: " + error.message);
        } finally {
            hideSpinner();
            enableAllButtons();
        }
    });

    /****************************************************
     * АВТОЗАПОВНЕННЯ ТЕМ ДНІВ
     ****************************************************/
    const autoFillDayThemesBtn = document.getElementById('autoFillDayThemesBtn');
    autoFillDayThemesBtn.addEventListener('click', async () => {
        const apiKey = localStorage.getItem('geminiApiKey');
        if (!apiKey) {
            alert('API ключ не знайдено! Спочатку збережіть ключ.');
            return;
        }

        // Дістанемо вибраний місяць і рік
        const yearSelect = document.getElementById('yearSelect').value;
        const monthSelect = document.getElementById('monthSelect').value;
        if (!yearSelect || !monthSelect) {
            alert('Спочатку оберіть рік та місяць!');
            return;
        }

        disableAllButtons();
        showSpinner();

        const year = parseInt(yearSelect, 10);
        const monthIndex = parseInt(monthSelect, 10) - 1;
        const monthName = monthNamesUkr[monthIndex] || "";

        try {
            // Обходимо кожен "Тиждень" (.page).
            const pages = document.querySelectorAll('.page');
            for (let page of pages) {
                const weekThemeInput = page.querySelector('.week-theme-input');
                if (!weekThemeInput) continue;

                const weekTheme = weekThemeInput.value.trim();
                if (!weekTheme) continue; // якщо не заповнено — пропускаємо

                // Знайдемо всі інпути .day-theme-input (для 3–5 днів, залежно від тижня)
                const dayInputs = page.querySelectorAll('.day-theme-input');
                const howManyDays = dayInputs.length;
                if (howManyDays === 0) continue;

                // Знайдемо дати та дні тижня для кожного дня
                const table = page.querySelector('table');
                if (!table) continue;
                const rows = table.querySelectorAll('tr');
                const dayData = [];
                for (let i = 1; i < rows.length; i++) { // починаємо з 1, щоб пропустити шапку
                    const row = rows[i];
                    const dayCell = row.querySelector('td');
                    const strong = dayCell.querySelector('strong');
                    if (!strong) continue;
                    const dateAndDayText = strong.textContent.trim(); // наприклад, "01.01 (Середа)"
                    dayData.push(dateAndDayText);
                }

                // Формуємо prompt для Gemini з врахуванням дат та можливих свят
                const promptText = `
Будь ласка, запропонуй ${howManyDays} актуальних коротких тем днів у дитячому садочку в Україні 
за загальною темою: "${weekTheme}" 
(період: ${monthName} ${year}, українською мовою). 
Кожну тему подай з нового рядка. 
Теми мають бути доречними для дошкільнят та враховувати державні свята України, якщо такі є на відповідні дні. ВАЖЛИВО: Свята повинні відповідати Григоріанському календарю.
Надай лише список тем, без додаткових пояснень та нумерації.
                `.trim();

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-thinking-exp-1219:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: promptText }]
                            }]
                        })
                    }
                );
                if (!response.ok) {
                    throw new Error(`Помилка від API: ${response.status}`);
                }
                const data = await response.json();
                let generatedText = data.candidates[0].content.parts.at(-1).text;

                // Спробуємо розділити результат на рядки
                const lines = generatedText
                    .split(/\r?\n/)
                    .map(l => l.replace(/^\d+\)\s*/, '').trim())
                    .filter(Boolean);

                // Заповнимо day-theme-input
                for (let i = 0; i < dayInputs.length; i++) {
                    if (i < lines.length) {
                        dayInputs[i].value = lines[i];
                    }
                }
            }
            // Зберігаємо зміни
            saveGeneratedPages();
            alert("Автозаповнення тем днів завершено!");
        } catch (error) {
            console.error(error);
            alert("Не вдалося отримати дані від Gemini API: " + error.message);
        } finally {
            hideSpinner();
            enableAllButtons();
        }
    });

    /****************************************************
     * АВТОЗАПОВНЕННЯ (ПОВНА ТАБЛИЦЯ)
     ****************************************************/
    const autoFillBtn = document.getElementById('autoFillBtn');
    autoFillBtn.addEventListener('click', async () => {
        const apiKey = localStorage.getItem('geminiApiKey');
        if (!apiKey) {
            alert('API ключ не знайдено! Спочатку збережіть ключ.');
            return;
        }

        // Для більш точного prompt-а (місяць, рік)
        const yearSelect = document.getElementById('yearSelect').value;
        const monthSelect = document.getElementById('monthSelect').value;
        if (!yearSelect || !monthSelect) {
            alert('Спочатку оберіть рік та місяць!');
            return;
        }

        disableAllButtons();
        showSpinner();

        const year = parseInt(yearSelect, 10);
        const monthIndex = parseInt(monthSelect, 10) - 1;
        const monthName = monthNamesUkr[monthIndex] || "";

        try {
            const pages = document.querySelectorAll('.page');

            // Для кожного тижня робимо окремий запит
            for (let page of pages) {
                // Тема тижня
                const weekThemeInput = page.querySelector('.week-theme-input');
                if (!weekThemeInput) continue;
                const weekTheme = weekThemeInput.value.trim();
                if (!weekTheme) continue;

                // Зберемо інформацію про дні
                const table = page.querySelector('table');
                if (!table) continue;

                const rows = table.querySelectorAll('tr');
                // Перший рядок – це шапка, тому починаємо з i=1
                const dayData = [];
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    const dayThemeInput = row.querySelector('.day-theme-input');
                    if (!dayThemeInput) continue;

                    const dayCell = row.querySelector('td');
                    const strong = dayCell.querySelector('strong');
                    let dayText = strong ? strong.textContent : '';
                    dayData.push({
                        dateAndDay: dayText.trim(),
                        dayTheme: dayThemeInput.value.trim()
                    });
                }

                // Формуємо prompt для Gemini (попросимо вивести JSON)
                const promptObj = {
                    weekTheme: weekTheme,
                    days: dayData
                };

                const promptText = `
Будь ласка, згенеруй план занять для дитячого садочка в Україні на тиждень (період: ${monthName} ${year}) 
за темою "${promptObj.weekTheme}". 
Для кожного дня (з його темою) вкажи 8 коротких активностей (українською мовою), кожна відповідає одній 
з освітніх ліній (1: «Особистість дитини», 2: «Дитина в соціумі», 3: «Дитина в природному довкіллі», 
4: «Дитина у світі культури», 5: «Мовлення дитини», 6: «Дитина в сенсорно-математичному просторі», 
7: «Гра дитини», 8: + ще одна на вибір). 
Просимо підлаштувати активності з урахуванням пори року та державних свят України. Свята повинні відповідати Григоріанському календарю.
Формат відповіді подай у JSON, де ключ "tableData" містить масив із об’єктами:
{
  "dateAndDay": "наприклад '01.01 (Середа)'",
  "dayTheme": "наприклад 'Пригоди сніговика'",
  "lines": [
    "короткий опис активності 1",
    "короткий опис активності 2",
    ... (усього 8 пунктів)
  ]
}

Важливо! Відповіді в масив "lines" з описом активностей не повинні містити нумерацію.

Ось перелік днів тижня і теми днів, які треба включити у план (масив у JSON):
${JSON.stringify(promptObj.days, null, 2)}
                `.trim();

                const response = await fetch(
                    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: promptText }]
                            }]
                        })
                    }
                );
                if (!response.ok) {
                    throw new Error(`Помилка від API: ${response.status}`);
                }
                const data = await response.json();

                // Спробуємо знайти JSON у тексті відповіді
                let generatedText = data.candidates[0].content.parts.at(-1).text;

                let cleaned = generatedText
                    .replace(/^```json\s*/i, '') // видаляє початок ```json
                    .replace('```', '')         // видаляє кінець ```
                    .trim();

                let parsedData = null;
                try {
                    parsedData = JSON.parse(cleaned);
                } catch (e) {
                    console.error("Помилка парсингу JSON:", e);
                    console.log("Відповідь від Gemini:", generatedText);
                    continue;
                }

                if (!parsedData || !parsedData.tableData) {
                    console.warn("У розпарсеному JSON немає tableData.");
                    continue;
                }

                // Заповнюємо рядки таблиці відповідно до отриманих даних
                for (let i = 1; i < rows.length; i++) {
                    const row = rows[i];
                    const dayCell = row.querySelector('td');
                    if (!dayCell) continue;
                    const strong = dayCell.querySelector('strong');
                    if (!strong) continue;

                    const currentDateAndDay = strong.textContent.trim();
                    // Знаходимо відповідний елемент у parsedData.tableData
                    const dayEntry = parsedData.tableData.find(entry => {
                        return entry.dateAndDay && entry.dateAndDay.includes(currentDateAndDay);
                    });

                    if (dayEntry && Array.isArray(dayEntry.lines)) {
                        const columns = row.querySelectorAll('td');
                        // columns[0] = dayCell, columns[1..7] = other cells
                        for (let colIndex = 1; colIndex < columns.length; colIndex++) {
                            if (dayEntry.lines[colIndex - 1]) {
                                columns[colIndex].textContent = dayEntry.lines[colIndex - 1];
                            }
                        }
                    }
                }
            }

            // Зберігаємо таблиці у localStorage
            saveGeneratedPages();
            alert("Повне автозаповнення таблиць завершено!");
        } catch (error) {
            console.error(error);
            alert("Не вдалося отримати дані від Gemini API: " + error.message);
        } finally {
            hideSpinner();
            enableAllButtons();
        }
    });

    /****************************************************
     * Заміна інпутів на текст при друку і повернення назад
     ****************************************************/
    const printBtn = document.getElementById('btnPrint');
    printBtn.addEventListener('click', function() {
        // 1. Зібрати всі інпути, перетворити їх на <span> з текстом
        const dayInputs = document.querySelectorAll('.day-theme-input');
        const weekInputs = document.querySelectorAll('.week-theme-input');

        // Масив, де будемо зберігати, що чим замінили
        const replacedElements = [];

        // Функція, що замінює input на span
        function replaceInputWithSpan(input) {
            const span = document.createElement('span');
            span.textContent = input.value.trim();
            // зберігаємо пари {оригінал, заміна}
            replacedElements.push({ original: input, temp: span });
            // замінюємо в DOM
            input.parentNode.replaceChild(span, input);
        }

        // Замінюємо всі dayTheme
        dayInputs.forEach(input => {
            replaceInputWithSpan(input);
        });
        // Замінюємо всі weekTheme
        weekInputs.forEach(input => {
            replaceInputWithSpan(input);
        });

        // 2. Викликаємо друк
        window.print();

        // 3. Після завершення друку — повертаємо все назад
        replacedElements.forEach(({ original, temp }) => {
            temp.parentNode.replaceChild(original, temp);
        });
    });
</script>

</body>
</html>
